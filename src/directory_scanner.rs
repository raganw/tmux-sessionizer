use crate::config::Config; // Add this to use the Config struct
use crate::container_detector;
use crate::error::Result; // Add this line to import your custom Result type
use crate::git_repository_handler::{self, is_git_repository, list_linked_worktrees};
use crate::path_utils::expand_tilde; // Add this import
use git2::Repository; // For repo.is_worktree()
use rayon::prelude::*; // Add Rayon prelude
use std::collections::HashSet; // Add this for HashSet
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Mutex; // Add Mutex for thread-safe HashSet access
use tracing::{Level, debug, error, info, span, warn}; // Add tracing imports
use walkdir::WalkDir; // Add this for directory traversal

#[derive(Debug, Clone, PartialEq)]
pub enum DirectoryType {
    Plain,
    GitRepository,
    GitWorktree {
        main_worktree_path: PathBuf,
    }, // Path to the main .git dir or main worktree's root
    #[allow(dead_code)]
    // This variant is used conceptually for exclusion, not direct construction of entries.
    GitWorktreeContainer, // A directory that primarily contains worktrees of a single main repo
}

#[derive(Debug, Clone, PartialEq)]
pub struct DirectoryEntry {
    pub path: PathBuf,
    pub resolved_path: PathBuf,
    pub display_name: String,
    pub entry_type: DirectoryType,
    pub parent_path: Option<PathBuf>, // For worktrees, to reference their main repo's path
}

pub struct DirectoryScanner<'a> {
    config: &'a Config,
}

impl<'a> DirectoryScanner<'a> {
    pub fn new(config: &'a Config) -> Self {
        Self { config }
    }

    // Modified helper: returns DirectoryEntry, no processed_paths or entries collection
    fn add_worktree_entry(
        original_wt_path: PathBuf, // The path as found by WalkDir or from git config
        resolved_wt_path: PathBuf, // The canonicalized path of the worktree
        main_repo_resolved_path: &Path,
        _worktree_name_opt: Option<String>, // Name from git worktree list, currently not used for display name per spec
    ) -> DirectoryEntry {
        // The check for processed_resolved_paths is now done in process_path_candidate before calling this.
        // debug!(path = %resolved_wt_path.display(), "Worktree path already processed, skipping"); // This log is removed

        let worktree_basename = resolved_wt_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy();
        let parent_basename = main_repo_resolved_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy();
        let display_name = format!("[{parent_basename}] {worktree_basename}");

        debug!(path = %resolved_wt_path.display(), main_repo = %main_repo_resolved_path.display(), name = %display_name, "Creating Git worktree entry details");
        DirectoryEntry {
            path: original_wt_path,          // Use the original path
            resolved_path: resolved_wt_path, // Pass resolved_wt_path directly
            display_name,
            entry_type: DirectoryType::GitWorktree {
                main_worktree_path: main_repo_resolved_path.to_path_buf(),
            },
            parent_path: Some(main_repo_resolved_path.to_path_buf()),
        }
    }

    #[allow(clippy::too_many_lines)]
    fn process_path_candidate(
        &self,
        original_path: PathBuf, // Path as found by WalkDir or from additional_paths
        is_explicitly_added: bool, // New flag
        processed_resolved_paths_mux: &Mutex<HashSet<PathBuf>>, // Changed parameter
    ) -> Result<Vec<DirectoryEntry>> {
        // Changed return type
        let candidate_span =
            span!(Level::DEBUG, "process_path_candidate", path = %original_path.display());
        let _enter = candidate_span.enter();

        let mut current_entries = Vec::new(); // Collect entries generated by this path

        let resolved_path = match fs::canonicalize(&original_path) {
            Ok(p) => p,
            Err(e) => {
                warn!(original_path = %original_path.display(), error = %e, "Could not canonicalize path, skipping this path");
                return Err(e.into()); // Propagate error for this path
            }
        };

        if !resolved_path.is_dir() {
            debug!(original_path = %original_path.display(), resolved_path = %resolved_path.display(), "Skipping as resolved path is not a directory");
            return Ok(Vec::new()); // Return empty vec for skip
        }

        // Explicitly skip .git directories found during scanning.
        if resolved_path.file_name().is_some_and(|name| name == ".git") {
            debug!(path = %resolved_path.display(), "Skipping .git directory");
            return Ok(Vec::new()); // Return empty vec for skip
        }

        debug!(original = %original_path.display(), resolved = %resolved_path.display(), "Path resolved");

        // Critical section for checking and inserting into processed_resolved_paths
        {
            let mut processed_paths_guard = processed_resolved_paths_mux.lock().map_err(|e| {
                error!("Mutex poisoned while accessing processed_resolved_paths: {e}");
                crate::error::AppError::MutexError(format!(
                    "Mutex poisoned while accessing processed_resolved_paths: {e}"
                ))
            })?;

            if processed_paths_guard.contains(&resolved_path) {
                debug!(path = %resolved_path.display(), "Skipping duplicate resolved path (checked in parallel context)");
                return Ok(Vec::new()); // Return empty vec for skip
            }
            // If we are going to process it, add it to the set.
            processed_paths_guard.insert(resolved_path.clone());
        } // Lock released

        for pattern in &self.config.exclude_patterns {
            if pattern.is_match(original_path.to_string_lossy().as_ref())
                || pattern.is_match(resolved_path.to_string_lossy().as_ref())
            {
                debug!(path = %resolved_path.display(), pattern = %pattern, "Skipping excluded path");
                return Ok(Vec::new()); // Return empty vec for skip
            }
        }

        let basename_of_resolved_path = resolved_path.file_name().map_or_else(
            || {
                original_path
                    .file_name()
                    .unwrap_or_default()
                    .to_string_lossy()
                    .into_owned()
            },
            |os_str| os_str.to_string_lossy().into_owned(),
        );

        let is_hidden_by_name = basename_of_resolved_path.starts_with('.')
            && basename_of_resolved_path.len() > 1
            && basename_of_resolved_path != ".git";

        if is_hidden_by_name && !is_explicitly_added {
            debug!(name = %basename_of_resolved_path, path = %resolved_path.display(), "Skipping hidden directory (not explicitly added)");
            return Ok(Vec::new()); // Return empty vec for skip
        }

        if is_git_repository(&resolved_path) {
            match Repository::open(&resolved_path) {
                Ok(repo) => {
                    if repo.is_worktree() {
                        match git_repository_handler::get_main_repository_path(&resolved_path) {
                            Ok(main_repo_path) => {
                                current_entries.push(Self::add_worktree_entry(
                                    original_path.clone(),
                                    resolved_path.clone(),
                                    &main_repo_path,
                                    None,
                                ));
                            }
                            Err(e) => {
                                warn!(path = %resolved_path.display(), error = %e, "Failed to get main repository path for worktree, treating as plain directory");
                                current_entries.push(Self::add_plain_directory_entry(
                                    original_path,
                                    resolved_path,
                                    basename_of_resolved_path,
                                ));
                            }
                        }
                    } else {
                        let mut add_repo_entry_as_git_repository = true;

                        if repo.is_bare()
                            && container_detector::is_bare_repo_worktree_exclusive_container(
                                &resolved_path,
                                &repo,
                            )?
                        {
                            debug!(path = %resolved_path.display(), "Identified as a bare repo worktree exclusive container. Skipping direct entry for the container itself, but its worktrees will be listed.");
                            add_repo_entry_as_git_repository = false;
                        }

                        if add_repo_entry_as_git_repository {
                            let repo_type_str = if repo.is_bare() {
                                "bare Git repository"
                            } else {
                                "standard Git repository"
                            };
                            debug!(path = %resolved_path.display(), name = %basename_of_resolved_path, type = repo_type_str, "Adding Git repository entry");
                            let repo_entry = DirectoryEntry {
                                path: original_path.clone(),
                                resolved_path: resolved_path.clone(),
                                display_name: basename_of_resolved_path.clone(),
                                entry_type: DirectoryType::GitRepository,
                                parent_path: None,
                            };
                            current_entries.push(repo_entry);
                        }

                        match list_linked_worktrees(&resolved_path) {
                            Ok(linked_worktrees) => {
                                debug!(repo_path = %resolved_path.display(), count = linked_worktrees.len(), "Found linked worktrees");
                                let main_repo_ref_path_for_display = resolved_path.clone();
                                for worktree_info in linked_worktrees {
                                    let wt_path_from_git = worktree_info.path;
                                    match fs::canonicalize(&wt_path_from_git) {
                                        Ok(canonical_wt_path) => {
                                            if !canonical_wt_path.is_dir() {
                                                warn!(wt_path = %wt_path_from_git.display(), resolved_wt_path = %canonical_wt_path.display(), "Linked worktree path is not a directory, skipping");
                                                continue;
                                            }

                                            // Check and claim the canonical_wt_path in the shared set.
                                            let mut processed_paths_guard = processed_resolved_paths_mux.lock().map_err(|e| {
                                                    error!("Mutex poisoned while checking linked worktree {}: {}", canonical_wt_path.display(), e);
                                                    crate::error::AppError::MutexError(format!("Mutex poisoned while checking linked worktree {}: {}", canonical_wt_path.display(), e))
                                                })?;

                                            if processed_paths_guard.contains(&canonical_wt_path) {
                                                debug!(path = %canonical_wt_path.display(), "Skipping linked worktree as its path is already processed or claimed by another scan item");
                                                // Release guard explicitly as we are continuing the loop
                                                drop(processed_paths_guard);
                                            } else {
                                                // Not processed, so claim it and add the entry.
                                                processed_paths_guard
                                                    .insert(canonical_wt_path.clone());
                                                // Release guard explicitly after insertion.
                                                drop(processed_paths_guard);

                                                current_entries.push(Self::add_worktree_entry(
                                                    wt_path_from_git.clone(),
                                                    canonical_wt_path, // This is the resolved path of the worktree
                                                    &main_repo_ref_path_for_display,
                                                    Some(worktree_info.name),
                                                ));
                                            }
                                        }
                                        Err(e) => {
                                            warn!(wt_path = %wt_path_from_git.display(), error = %e, "Could not canonicalize linked worktree path, skipping");
                                        }
                                    }
                                }
                            }
                            Err(e) => {
                                warn!(repo_path = %resolved_path.display(), error = %e, "Failed to list linked worktrees");
                            }
                        }
                    }
                }
                Err(e) => {
                    warn!(path = %resolved_path.display(), error = %e, "Failed to open path as Git repository despite initial check, treating as plain");
                    if container_detector::check_if_worktree_container(&resolved_path)? {
                        debug!(path = %resolved_path.display(), "Identified as a Git worktree container (after failing to open as repo), skipping");
                        return Ok(Vec::new()); // Return empty vec for skip
                    }
                    current_entries.push(Self::add_plain_directory_entry(
                        original_path,
                        resolved_path,
                        basename_of_resolved_path,
                    ));
                }
            }
        } else {
            if container_detector::check_if_worktree_container(&resolved_path)? {
                debug!(path = %resolved_path.display(), "Identified as a Git worktree container, skipping");
                return Ok(Vec::new()); // Return empty vec for skip
            }
            current_entries.push(Self::add_plain_directory_entry(
                original_path,
                resolved_path,
                basename_of_resolved_path,
            ));
        }
        Ok(current_entries)
    }

    // Modified helper: returns DirectoryEntry, no processed_paths or entries collection
    fn add_plain_directory_entry(
        original_path: PathBuf,
        resolved_path: PathBuf,
        display_name: String, // This is already basename of resolved_path
    ) -> DirectoryEntry {
        // The check for processed_resolved_paths is now done in process_path_candidate.
        // debug!(path = %resolved_path.display(), "Plain directory path already processed, skipping"); // This log is removed

        debug!(name = %display_name, path = %resolved_path.display(), "Creating plain directory entry details");
        DirectoryEntry {
            path: original_path, // Use the original path
            resolved_path,       // Pass resolved_path directly
            display_name,        // Basename of resolved_path
            entry_type: DirectoryType::Plain,
            parent_path: None,
        }
    }

    pub fn scan(&self) -> Vec<DirectoryEntry> {
        let scan_span = span!(Level::INFO, "directory_scan");
        let _enter = scan_span.enter();
        info!("Starting directory scan");

        // Mutex for thread-safe access to the set of processed resolved paths
        let processed_resolved_paths_mux = Mutex::new(HashSet::new());
        let mut paths_to_process: Vec<(PathBuf, bool)> = Vec::new(); // (path, is_explicitly_added)

        debug!(search_paths = ?self.config.search_paths, "Collecting paths from search_paths");
        for search_path_config_entry in &self.config.search_paths {
            let path_span = span!(Level::DEBUG, "collect_search_root", config_path = %search_path_config_entry.display());
            let _path_enter = path_span.enter();

            let Some(search_path_base) = expand_tilde(search_path_config_entry) else {
                warn!(path = %search_path_config_entry.display(), "Could not expand tilde for search path, skipping");
                continue;
            };
            debug!(expanded_path = %search_path_base.display(), "Expanded search path");

            if !search_path_base.is_dir() {
                warn!(path = %search_path_base.display(), "Search path is not a directory or is inaccessible, skipping");
                continue;
            }

            debug!(path = %search_path_base.display(), "Collecting direct children for parallel processing");
            paths_to_process.extend(
                WalkDir::new(&search_path_base)
                    .min_depth(1)
                    .max_depth(1)
                    .follow_links(true)
                    .into_iter()
                    .filter_map(|e_result| match e_result {
                        Ok(entry) => Some((entry.path().to_path_buf(), false)), // false for is_explicitly_added
                        Err(err_val) => {
                            let io_error_string = err_val
                                .io_error()
                                .map_or_else(|| "N/A".to_string(), std::string::ToString::to_string);
                            warn!(path = ?err_val.path(), error = %io_error_string, "Error walking directory child, skipping this child");
                            None
                        }
                    }),
            );
        }

        debug!(additional_paths = ?self.config.additional_paths, "Collecting additional paths");
        for additional_path_config_entry in &self.config.additional_paths {
            let path_span = span!(Level::DEBUG, "collect_additional_path", config_path = %additional_path_config_entry.display());
            let _path_enter = path_span.enter();

            let Some(original_path) = expand_tilde(additional_path_config_entry) else {
                warn!(path = %additional_path_config_entry.display(), "Could not expand tilde for additional path, skipping");
                continue;
            };
            debug!(expanded_path = %original_path.display(), "Expanded additional path");
            paths_to_process.push((original_path, true)); // true for is_explicitly_added
        }

        info!(
            count = paths_to_process.len(),
            "Collected initial paths for parallel processing"
        );

        // Parallel processing of collected paths
        let results: Vec<Result<Vec<DirectoryEntry>>> = paths_to_process
            .into_par_iter()
            .map(|(path, is_explicit)| {
                self.process_path_candidate(path, is_explicit, &processed_resolved_paths_mux)
            })
            .collect();

        // Consolidate results from parallel tasks
        let mut all_entries = Vec::new();
        for result_vec in results {
            match result_vec {
                Ok(entries_vec) => {
                    all_entries.extend(entries_vec);
                }
                Err(e) => {
                    // Log errors from individual path processing but continue with other results.
                    // These errors are specific to one path (e.g., canonicalization failure).
                    warn!(
                        "Error processing a path during scan: {}. This path was skipped.",
                        e
                    );
                }
            }
        }

        // Deduplication based on resolved_path is handled *inside* process_path_candidate
        // using the Mutex-guarded HashSet. So, `all_entries` should be unique by resolved_path
        // for top-level entries. Worktrees added as children of a repo are not subject to this
        // top-level Mutex check unless their path also happened to be a top-level scan item.

        info!(
            count = all_entries.len(),
            "Directory scan complete (after parallel processing and consolidation)"
        );
        debug!(final_entries = ?all_entries, "Final list of directory entries");
        all_entries
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::Config;
    use crate::directory_scanner::DirectoryType; // Added for matching
    use git2::{Repository, Signature, WorktreeAddOptions}; // Added Signature
    use std::fs::{self, File}; // Added File
    use std::path::Path; // Added Path
    use tempfile::tempdir;
    // Required for MutexGuard, though not directly used in assertions, it's part of process_entry signature
    // use std::sync::MutexGuard; No, this is an internal detail, not needed for test setup.

    // Helper to initialize a standard git repo
    fn init_repo(path: &Path) -> Repository {
        Repository::init(path).expect("Failed to init repo")
    }

    // Helper to initialize a bare git repo
    fn init_bare_repo(path: &Path) -> Repository {
        Repository::init_bare(path).expect("Failed to init bare repo")
    }

    // Helper to add a worktree to a bare repository
    fn add_worktree_to_bare(bare_repo: &Repository, worktree_name: &str, worktree_path: &Path) {
        // Changed return type from Repository to ()
        // Create an initial commit if the repo is empty, which is necessary for worktree creation.
        if bare_repo.is_empty().unwrap_or(true) {
            let mut index = bare_repo
                .index()
                .expect("Failed to get index for bare repo");
            let tree_id = index.write_tree().expect("Failed to write empty tree");
            let tree = bare_repo.find_tree(tree_id).expect("Failed to find tree");
            let sig = Signature::now("Test User", "test@example.com")
                .expect("Failed to create signature");
            bare_repo
                .commit(
                    Some("HEAD"),     // Update HEAD
                    &sig,             // Author
                    &sig,             // Committer
                    "Initial commit", // Commit message
                    &tree,            // Tree
                    &[],              // No parent commits
                )
                .expect("Failed to create initial commit in bare repo");
        }

        let mut opts = WorktreeAddOptions::new();
        // opts.reference(Some(&bare_repo.head().unwrap().peel_to_commit().unwrap().id().into()));
        // The above is more robust but requires a valid HEAD. Simpler:
        // opts.reference(None); // This should checkout HEAD by default if available

        bare_repo
            .worktree(worktree_name, worktree_path, Some(&mut opts))
            .unwrap_or_else(|_| {
                panic!("Failed to add worktree '{worktree_name}' at path {worktree_path:?}")
            });
        // Repository::open(worktree_path).expect("Failed to open added worktree") // Removed return value
    }

    // *** ADD THIS FUNCTION ***
    // New helper: Add a worktree to a standard repository
    fn add_worktree_to_standard_repo(
        repo_path: &Path,              // Path to the standard repository's working directory
        worktree_name: &str,           // Name for the new worktree (e.g., "feature-branch")
        worktree_checkout_path: &Path, // Path where the new worktree will be checked out
    ) {
        let repo = Repository::open(repo_path).expect("Failed to open repo for adding worktree");
        if repo.head().is_err() {
            let mut index = repo.index().expect("Failed to get repo index");
            // Create an empty file to be able to create a non-empty tree
            let repo_file_path = repo_path.join("initial_file.txt");
            File::create(&repo_file_path).expect("Failed to create initial file in repo");
            index
                .add_path(Path::new("initial_file.txt"))
                .expect("Failed to add file to index");

            let id = index.write_tree().expect("Failed to write tree");
            let tree = repo.find_tree(id).expect("Failed to find tree");
            let sig =
                Signature::now("test", "test@example.com").expect("Failed to create signature");
            repo.commit(Some("HEAD"), &sig, &sig, "Initial commit", &tree, &[])
                .expect("Failed to create initial commit");
        }
        // Ensure the worktree path parent directory exists
        if let Some(parent) = worktree_checkout_path.parent() {
            fs::create_dir_all(parent).expect("Failed to create parent directory for worktree");
        }
        repo.worktree(worktree_name, worktree_checkout_path, None) // None for default options
            .unwrap_or_else(|_| {
                panic!("Failed to add worktree {worktree_name} at {worktree_checkout_path:?}")
            });
    }

    // Helper to create a default config for tests
    fn default_test_config() -> Config {
        Config {
            search_paths: vec![],
            additional_paths: vec![],
            exclude_patterns: vec![],
            debug_mode: false, // or true for more test output
            direct_selection: None,
            // Initialize other fields if they become non-optional or affect tests
        }
    }

    // *** ADD THIS FUNCTION ***
    // Helper to find an entry by a suffix of its resolved_path
    // and assert its properties.
    fn assert_entry_properties(
        entries: &[DirectoryEntry],
        path_suffix: &str,
        expected_type: &str, // Use string representation for easier comparison in tests
        expected_display_name: &str,
    ) {
        let entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with(path_suffix))
            .unwrap_or_else(|| {
                panic!("Entry ending with '{path_suffix}' not found in entries: {entries:?}")
            }); // Added entries to panic msg

        match &entry.entry_type {
            DirectoryType::Plain => assert_eq!(expected_type, "Plain"),
            DirectoryType::GitRepository => assert_eq!(expected_type, "GitRepository"),
            DirectoryType::GitWorktreeContainer => {
                assert_eq!(expected_type, "GitWorktreeContainer")
            } // This type might not be directly asserted often
            DirectoryType::GitWorktree {
                main_worktree_path: _,
            } => assert_eq!(expected_type, "GitWorktree"), // Adjusted match arm
        }
        assert_eq!(entry.display_name, expected_display_name);

        // Specific checks for GitWorktree
        if expected_type == "GitWorktree" {
            if let DirectoryType::GitWorktree {
                main_worktree_path, ..
            } = &entry.entry_type
            {
                // Removed worktree_name check here as it's not stored in DirectoryEntry
                // Display name for worktree is usually "[main_repo_name] worktree_basename"
                // We can check if the expected_display_name matches the format
                assert!(expected_display_name.contains('[') && expected_display_name.contains(']'));
                // main_worktree_path should be valid.
                assert!(
                    main_worktree_path.exists(),
                    "Main worktree path {main_worktree_path:?} does not exist"
                );
            } else {
                panic!(
                    "Mismatched type: expected GitWorktree, found something else after string match."
                );
            }
        }
    }

    #[test]
    fn test_scan_skips_bare_repo_container_lists_its_worktrees() {
        let base_dir = tempdir().unwrap();

        // Setup the container structure
        let container_path = base_dir.path().join("my_bare_container");
        fs::create_dir(&container_path).unwrap();
        let bare_repo_dir_name = "internal_bare.git";
        let bare_repo_actual_path = container_path.join(bare_repo_dir_name);
        fs::create_dir(&bare_repo_actual_path).unwrap();
        let _ = init_bare_repo(&bare_repo_actual_path); // Initialize the bare repo
        fs::write(
            container_path.join(".git"),
            format!("gitdir: {bare_repo_dir_name}"),
        )
        .unwrap(); // Link .git file

        let container_repo_obj = Repository::open(&container_path)
            .expect("Failed to open container path as repo for test setup");

        let wt1_path = container_path.join("feature_a");
        add_worktree_to_bare(&container_repo_obj, "feature_a", &wt1_path);
        let wt2_path = container_path.join("bugfix_b");
        add_worktree_to_bare(&container_repo_obj, "bugfix_b", &wt2_path);

        // Add a plain project for control
        let plain_project_path = base_dir.path().join("plain_old_project");
        fs::create_dir(&plain_project_path).unwrap();

        let mut config = default_test_config();
        config.search_paths = vec![base_dir.path().to_path_buf()]; // Scan children of base_dir

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        let canonical_container_path = fs::canonicalize(&container_path).unwrap();
        let canonical_wt1_path = fs::canonicalize(&wt1_path).unwrap();
        let canonical_wt2_path = fs::canonicalize(&wt2_path).unwrap();
        let canonical_plain_project_path = fs::canonicalize(&plain_project_path).unwrap();

        let container_name = container_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy();

        // The container itself should NOT be an entry
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path == canonical_container_path),
            "Bare repo container itself should be skipped. Entries: {:?}",
            &entries
        );

        // Its worktrees SHOULD be entries
        let wt1_entry = entries
            .iter()
            .find(|e| e.resolved_path == canonical_wt1_path);
        assert!(
            wt1_entry.is_some(),
            "Worktree 1 should be listed. Entries: {:?}",
            &entries
        );
        assert!(
            matches!(
                wt1_entry.unwrap().entry_type,
                DirectoryType::GitWorktree { .. }
            ),
            "Worktree 1 should be of type GitWorktree"
        );
        assert_eq!(
            wt1_entry.unwrap().display_name,
            format!("[{container_name}] feature_a")
        );

        let wt2_entry = entries
            .iter()
            .find(|e| e.resolved_path == canonical_wt2_path);
        assert!(
            wt2_entry.is_some(),
            "Worktree 2 should be listed. Entries: {:?}",
            &entries
        );
        assert!(
            matches!(
                wt2_entry.unwrap().entry_type,
                DirectoryType::GitWorktree { .. }
            ),
            "Worktree 2 should be of type GitWorktree"
        );
        assert_eq!(
            wt2_entry.unwrap().display_name,
            format!("[{container_name}] bugfix_b")
        );

        // The plain project should be an entry
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_plain_project_path
                    && e.entry_type == DirectoryType::Plain),
            "Plain project should be listed. Entries: {:?}",
            &entries
        );

        // Total entries: wt1, wt2, plain_project = 3
        // Note: The order of entries might change due to parallel processing.
        // The exact number of entries depends on how linked worktrees are handled if their paths
        // are also discovered independently. The Mutex<HashSet> for processed_resolved_paths
        // aims to prevent double-listing of the *same resolved path* if it's encountered
        // as a top-level item. Worktrees listed as children of a repo are distinct entries
        // unless their resolved path was already processed as a top-level item.
        // In this specific test, container_path is a top-level item. It's skipped.
        // Its worktrees (wt1_path, wt2_path) are added because list_linked_worktrees is called.
        // If wt1_path or wt2_path were *also* direct children of base_dir and thus top-level items,
        // the Mutex would prevent them from being processed twice. Here they are not.
        assert_eq!(
            entries.len(),
            3,
            "Expected 3 entries (2 worktrees, 1 plain project). Entries: {:?}",
            &entries
        );
    }

    #[test]
    fn test_scan_excludes_worktree_container() {
        // This tests the original check_if_worktree_container
        let base_dir = tempdir().unwrap();
        let main_repo_dir = base_dir.path().join("main_bare_repo_for_other_container"); // Different main repo
        fs::create_dir(&main_repo_dir).unwrap();
        let _main_repo = init_bare_repo(&main_repo_dir);

        // This container is NOT a repo itself, its children are worktrees of _main_repo
        let non_repo_container_dir_path = base_dir.path().join("non_repo_worktree_holder");
        fs::create_dir(&non_repo_container_dir_path).unwrap();

        let wt1_path = non_repo_container_dir_path.join("wt1_in_non_repo_container");
        add_worktree_to_bare(&_main_repo, "wt1_in_non_repo_container", &wt1_path);
        let wt2_path = non_repo_container_dir_path.join("wt2_in_non_repo_container");
        add_worktree_to_bare(&_main_repo, "wt2_in_non_repo_container", &wt2_path);

        let plain_dir_path = base_dir.path().join("plain_project_for_container_test");
        fs::create_dir(&plain_dir_path).unwrap();

        let mut config = default_test_config();
        config.search_paths = vec![base_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        let canonical_main_repo_dir = fs::canonicalize(&main_repo_dir).unwrap();
        // wt1 and wt2 are children of non_repo_container_dir_path.
        // non_repo_container_dir_path itself is scanned as a top-level item.
        // It should be identified as a worktree container and skipped (returning Ok(vec![])).
        // The worktrees wt1 and wt2 are *also* listed because main_repo_dir (another top-level item)
        // is processed, and list_linked_worktrees is called on it.
        let canonical_wt1_path = fs::canonicalize(&wt1_path).unwrap();
        let canonical_wt2_path = fs::canonicalize(&wt2_path).unwrap();
        let canonical_plain_dir_path = fs::canonicalize(&plain_dir_path).unwrap();
        let canonical_container_dir_path = fs::canonicalize(&non_repo_container_dir_path).unwrap();

        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_main_repo_dir)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_wt1_path)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_wt2_path)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_plain_dir_path)
        );
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path == canonical_container_dir_path),
            "Non-repo worktree container should be excluded. Entries: {:?}",
            &entries
        );

        // main_repo_dir, its 2 worktrees, plain_project = 4 entries
        assert_eq!(
            entries.len(),
            4,
            "Expected 4 entries. Entries: {:?}",
            &entries
        );
    }

    #[test]
    fn test_scan_finds_various_types() {
        let base_dir = tempdir().unwrap();

        let plain_project_path = base_dir.path().join("my_plain_project");
        fs::create_dir(&plain_project_path).unwrap();

        let git_project_path = base_dir.path().join("my_git_project");
        init_repo(&git_project_path);

        let main_bare_repo_path = base_dir.path().join("central_bare.git");
        let main_bare_repo = init_bare_repo(&main_bare_repo_path);

        let worktree1_path = base_dir.path().join("worktree_one"); // worktree of central_bare.git
        add_worktree_to_bare(&main_bare_repo, "wt_one", &worktree1_path);

        let mut config = default_test_config();
        config.search_paths = vec![base_dir.path().to_path_buf()];
        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        // Expected: plain_project, git_project, central_bare.git, worktree_one
        // central_bare.git will list worktree_one.
        // If worktree_one is also processed as a top-level item, the Mutex should prevent duplication.
        assert_eq!(
            entries.len(),
            4,
            "Should find plain, git repo, bare repo, and its worktree. Entries: {:?}",
            &entries
        );

        let canonical_plain_project_path = fs::canonicalize(&plain_project_path).unwrap();
        let canonical_git_project_path = fs::canonicalize(&git_project_path).unwrap();
        let canonical_main_bare_repo_path = fs::canonicalize(&main_bare_repo_path).unwrap();
        let canonical_worktree1_path = fs::canonicalize(&worktree1_path).unwrap();

        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_plain_project_path
                    && e.entry_type == DirectoryType::Plain)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_git_project_path
                    && e.entry_type == DirectoryType::GitRepository)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_main_bare_repo_path
                    && e.entry_type == DirectoryType::GitRepository)
        ); // The bare repo itself is an entry
        let wt1_entry = entries
            .iter()
            .find(|e| e.resolved_path == canonical_worktree1_path);
        assert!(wt1_entry.is_some());
        assert!(matches!(
            wt1_entry.unwrap().entry_type,
            DirectoryType::GitWorktree { .. }
        ));
        assert_eq!(
            wt1_entry.unwrap().display_name,
            "[central_bare.git] worktree_one"
        );
    }

    #[test]
    fn test_scan_with_tilde_expansion_and_additional_paths() {
        // This test is a bit conceptual for tilde as it depends on `dirs::home_dir()`
        // We'll simulate a structure that would be found if tilde expansion worked.
        let home_sim_dir = tempdir().unwrap();
        let dev_dir_in_home = home_sim_dir.path().join("Development");
        fs::create_dir_all(&dev_dir_in_home).unwrap();
        let project_in_dev_path = dev_dir_in_home.join("my_dev_project");
        fs::create_dir(&project_in_dev_path).unwrap();

        let other_loc_dir = tempdir().unwrap();
        let additional_project_path = other_loc_dir.path().join("additional_proj");
        fs::create_dir(&additional_project_path).unwrap();

        // Mock `expand_tilde` for this test by using paths that don't need it,
        // or ensure the test environment has a home dir.
        // For simplicity, we'll use absolute paths in config for this test,
        // assuming `expand_tilde` is tested elsewhere or works.
        // Or, we can test `expand_tilde` separately.
        // Here, we'll construct search_paths that mimic post-tilde-expansion.

        let mut config = default_test_config();
        // If we could mock dirs::home_dir(), we'd use "~/Development"
        // Instead, use the actual path for testing the rest of scan logic
        config.search_paths = vec![dev_dir_in_home.clone()];
        config.additional_paths = vec![additional_project_path.clone()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(entries.len(), 2, "Entries: {:?}", &entries);

        let canonical_project_in_dev_path = fs::canonicalize(&project_in_dev_path).unwrap();
        let canonical_additional_project_path = fs::canonicalize(&additional_project_path).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_project_in_dev_path)
        );
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_additional_project_path)
        );
    }

    #[test]
    fn test_scan_exclusion_patterns() {
        let base_dir = tempdir().unwrap();
        let project_a_path = base_dir.path().join("project_a");
        fs::create_dir(&project_a_path).unwrap();
        let project_b_path = base_dir.path().join("project_b_exclude");
        fs::create_dir(&project_b_path).unwrap();

        use regex::Regex; // Move Regex import here as it's only used in this test block
        let mut config = default_test_config();
        config.search_paths = vec![base_dir.path().to_path_buf()];
        config.exclude_patterns = vec![Regex::new("_exclude$").unwrap()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(entries.len(), 1);

        let canonical_project_a_path = fs::canonicalize(&project_a_path).unwrap();
        let canonical_project_b_path = fs::canonicalize(&project_b_path).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_project_a_path)
        );
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path == canonical_project_b_path)
        );
    }

    #[test]
    fn test_scan_hidden_directory_exclusion_in_walkdir() {
        let base_dir = tempdir().unwrap();
        let visible_project_path = base_dir.path().join("visible_project");
        fs::create_dir(&visible_project_path).unwrap();
        let hidden_project_path = base_dir.path().join(".hidden_project");
        fs::create_dir(&hidden_project_path).unwrap();

        let mut config = default_test_config();
        config.search_paths = vec![base_dir.path().to_path_buf()]; // Scan base_dir children

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(
            entries.len(),
            1,
            "Only visible_project should be found. Entries: {:?}",
            &entries
        );

        let canonical_visible_project_path = fs::canonicalize(&visible_project_path).unwrap();
        let canonical_hidden_project_path = fs::canonicalize(&hidden_project_path).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_visible_project_path)
        );
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path == canonical_hidden_project_path)
        );
    }

    #[test]
    fn test_scan_includes_explicitly_added_hidden_directory() {
        // e.g. if "~/.config" is an additional_path
        let base_dir = tempdir().unwrap();
        let hidden_config_path = base_dir.path().join(".myconfig");
        fs::create_dir(&hidden_config_path).unwrap();

        let mut config = default_test_config();
        config.additional_paths = vec![hidden_config_path.clone()]; // Explicitly add .myconfig

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(
            entries.len(),
            1,
            "Explicitly added hidden dir should be found. Entries: {:?}",
            &entries
        );

        let canonical_hidden_config_path = fs::canonicalize(&hidden_config_path).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.resolved_path == canonical_hidden_config_path)
        );
    }

    // *** ADD ALL THE FOLLOWING TESTS ***

    #[test]
    fn test_scan_empty_directory() {
        let temp_dir = tempdir().unwrap();
        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert!(
            entries.is_empty(),
            "Scan of empty directory should yield no entries"
        );
    }

    #[test]
    fn test_scan_single_level_directories_plain() {
        let temp_dir = tempdir().unwrap();
        fs::create_dir(temp_dir.path().join("dir1")).unwrap();
        fs::create_dir(temp_dir.path().join("dir2")).unwrap();

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let mut entries = scanner.scan();
        entries.sort_by(|a, b| a.resolved_path.cmp(&b.resolved_path));

        assert_eq!(entries.len(), 2);
        assert_entry_properties(&entries, "dir1", "Plain", "dir1");
        assert_entry_properties(&entries, "dir2", "Plain", "dir2");
    }

    #[test]
    fn test_scan_explicitly_added_path_no_recursion() {
        let temp_dir = tempdir().unwrap();
        let project_root = temp_dir.path().join("project_root");
        fs::create_dir_all(project_root.join("subdir")).unwrap();

        let mut config = default_test_config();
        config.additional_paths = vec![project_root.clone()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(entries.len(), 1);
        assert_entry_properties(&entries, "project_root", "Plain", "project_root");
        // "subdir" should not be listed as an entry
        assert!(!entries.iter().any(|e| e.resolved_path.ends_with("subdir")));
    }

    #[test]
    fn test_scan_search_path_one_level_recursion() {
        let temp_dir = tempdir().unwrap();
        let level1_path = temp_dir.path().join("level1");
        fs::create_dir_all(level1_path.join("level2")).unwrap();

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(entries.len(), 1);
        assert_entry_properties(&entries, "level1", "Plain", "level1");
        // "level2" should not be listed
        assert!(!entries.iter().any(|e| e.resolved_path.ends_with("level2")));
    }

    #[test]
    fn test_scan_with_exclude_pattern_simple() {
        let temp_dir = tempdir().unwrap();
        fs::create_dir(temp_dir.path().join("project1")).unwrap();
        fs::create_dir(temp_dir.path().join("node_modules")).unwrap();
        fs::create_dir(temp_dir.path().join("project2")).unwrap();
        use regex::Regex; // Move Regex import here as it's only used in this test block

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];
        config.exclude_patterns = vec![Regex::new("node_modules").unwrap()];

        let scanner = DirectoryScanner::new(&config);
        let mut entries = scanner.scan();
        entries.sort_by(|a, b| a.resolved_path.cmp(&b.resolved_path));

        assert_eq!(entries.len(), 2);
        assert_entry_properties(&entries, "project1", "Plain", "project1");
        assert_entry_properties(&entries, "project2", "Plain", "project2");
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path.ends_with("node_modules"))
        );
    }

    #[test]
    fn test_scan_with_exclude_pattern_wildcard_directory() {
        let temp_dir = tempdir().unwrap();
        fs::create_dir(temp_dir.path().join("project_code")).unwrap();
        fs::create_dir(temp_dir.path().join("logs_dir_main")).unwrap();
        fs::create_dir(temp_dir.path().join("another_dir")).unwrap();
        use regex::Regex; // Move Regex import here as it's only used in this test block

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];
        config.exclude_patterns = vec![Regex::new(r"logs_dir.*").unwrap()];

        let scanner = DirectoryScanner::new(&config);
        let mut entries = scanner.scan();
        entries.sort_by(|a, b| a.resolved_path.cmp(&b.resolved_path));

        assert_eq!(entries.len(), 2);
        assert_entry_properties(&entries, "another_dir", "Plain", "another_dir");
        assert_entry_properties(&entries, "project_code", "Plain", "project_code");
        assert!(
            !entries
                .iter()
                .any(|e| e.resolved_path.ends_with("logs_dir_main"))
        );
    }

    #[test]
    fn test_scan_with_multiple_exclude_patterns() {
        let temp_dir = tempdir().unwrap();
        fs::create_dir(temp_dir.path().join("src")).unwrap();
        fs::create_dir(temp_dir.path().join("target")).unwrap();
        fs::create_dir(temp_dir.path().join("docs")).unwrap();
        fs::create_dir(temp_dir.path().join("vendor")).unwrap();
        use regex::Regex; // Move Regex import here as it's only used in this test block

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];
        config.exclude_patterns = vec![
            Regex::new("target$").unwrap(), // Match directory name at the end
            Regex::new("vendor$").unwrap(),
        ];

        let scanner = DirectoryScanner::new(&config);
        let mut entries = scanner.scan();
        entries.sort_by(|a, b| a.resolved_path.cmp(&b.resolved_path));

        assert_eq!(entries.len(), 2);
        assert_entry_properties(&entries, "docs", "Plain", "docs");
        assert_entry_properties(&entries, "src", "Plain", "src");
    }

    #[test]
    fn test_scan_standard_git_repository() {
        let temp_dir = tempdir().unwrap();
        let repo_path = temp_dir.path().join("my_repo");
        init_repo(&repo_path);

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(entries.len(), 1);
        assert_entry_properties(&entries, "my_repo", "GitRepository", "my_repo");
    }

    #[test]
    fn test_scan_bare_git_repository_as_container() {
        // This test assumes the container_detector identifies it correctly.
        // The scanner itself should just list it as GitRepository unless the detector logic
        // inside process_path_candidate skips it.
        // Let's refine this test based on the current logic in process_path_candidate.
        let temp_dir = tempdir().unwrap();
        let bare_repo_path = temp_dir.path().join("my_bare_repo.git");
        let bare_repo = init_bare_repo(&bare_repo_path);

        // Add a worktree so it *might* be detected as a container
        let worktrees_dir = temp_dir.path().join("worktrees_of_bare");
        fs::create_dir(&worktrees_dir).unwrap();
        let wt_a_path = worktrees_dir.join("wt_a");
        add_worktree_to_bare(&bare_repo, "wt_a", &wt_a_path);

        let mut config = default_test_config();
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        // Current logic in process_path_candidate:
        // 1. Checks if it's a git repo -> Yes (bare)
        // 2. Checks if repo.is_bare() && container_detector::is_bare_repo_worktree_exclusive_container()
        //    - If true, it skips adding the bare repo itself.
        //    - If false, it adds the bare repo as GitRepository.
        // 3. Lists linked worktrees (wt_a).
        // 4. WalkDir also finds worktrees_of_bare (Plain) and wt_a (Worktree).
        // 5. Deduplication happens via Mutex.

        // Let's assume the container detector *does* identify it as exclusive container.
        // Then the bare repo itself should NOT be listed.
        // UPDATE: Assuming the detector does NOT identify this specific setup as exclusive,
        // the bare repo *should* be listed. Let's test for that.
        let bare_repo_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("my_bare_repo.git"));
        assert!(
            bare_repo_entry.is_some(),
            "Bare repo should be listed. Entries: {entries:?}"
        );
        assert_entry_properties(
            &entries,
            "my_bare_repo.git",
            "GitRepository",
            "my_bare_repo.git",
        );

        // The worktree should be listed.
        let wt_a_entry = entries.iter().find(|e| e.resolved_path.ends_with("wt_a"));
        assert!(
            wt_a_entry.is_some(),
            "Worktree wt_a should be listed. Entries: {entries:?}"
        );
        assert_entry_properties(&entries, "wt_a", "GitWorktree", "[my_bare_repo.git] wt_a");

        // The directory containing the worktree should also be listed if found by WalkDir.
        let worktrees_dir_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("worktrees_of_bare"));
        // UPDATE: Assuming check_if_worktree_container correctly skips "worktrees_of_bare"
        assert!(
            worktrees_dir_entry.is_none(),
            "Worktree container dir ('worktrees_of_bare') should be skipped. Entries: {entries:?}"
        );

        // Expected entries: my_bare_repo.git, wt_a = 2
        assert_eq!(
            entries.len(),
            2,
            "Expected 2 entries (bare repo, worktree). Entries: {entries:?}"
        );
    }

    #[test]
    fn test_scan_git_worktree() {
        let temp_dir = tempdir().unwrap();
        let main_repo_path = temp_dir.path().join("main_repo");
        init_repo(&main_repo_path);

        let worktree_dir = temp_dir.path().join("worktrees");
        fs::create_dir(&worktree_dir).unwrap();
        let worktree_checkout_path = worktree_dir.join("wt1");

        add_worktree_to_standard_repo(&main_repo_path, "wt1", &worktree_checkout_path);

        let mut config = default_test_config();
        // Scan the directory containing the worktree
        config.search_paths = vec![worktree_dir.clone()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        assert_eq!(
            entries.len(),
            1,
            "Should find one entry, the worktree. Entries: {entries:?}"
        );
        let entry = &entries[0];
        assert!(entry.resolved_path.ends_with("wt1"));
        assert_eq!(entry.display_name, "[main_repo] wt1"); // Updated expected display name format
        match &entry.entry_type {
            DirectoryType::GitWorktree {
                main_worktree_path, ..
            } => {
                // Removed worktree_name check
                assert_eq!(
                    *main_worktree_path,
                    fs::canonicalize(&main_repo_path).unwrap()
                );
            }
            _ => panic!("Expected GitWorktree, found {:?}", entry.entry_type),
        }
    }

    #[test]
    fn test_scan_bare_repo_with_linked_worktrees() {
        let temp_dir = tempdir().unwrap();
        let bare_repo_path = temp_dir.path().join("bare_repo.git");
        let bare_repo = init_bare_repo(&bare_repo_path);

        let worktrees_dir = temp_dir.path().join("worktrees_of_bare");
        fs::create_dir(&worktrees_dir).unwrap();
        let wt_a_path = worktrees_dir.join("wt_a");
        let wt_b_path = worktrees_dir.join("wt_b");

        add_worktree_to_bare(&bare_repo, "wt_a", &wt_a_path);
        add_worktree_to_bare(&bare_repo, "wt_b", &wt_b_path);

        let mut config = default_test_config();
        // Scan the parent directory which contains both the bare repo and the worktrees directory
        config.search_paths = vec![temp_dir.path().to_path_buf()];

        let scanner = DirectoryScanner::new(&config);
        let mut entries = scanner.scan();
        entries.sort_by(|a, b| a.resolved_path.cmp(&b.resolved_path));

        // Expected:
        // - bare_repo.git (skipped if detected as exclusive container, otherwise GitRepository)
        // - worktrees_of_bare (Plain)
        // - wt_a (GitWorktree, listed via bare repo processing or WalkDir + Mutex)
        // - wt_b (GitWorktree, listed via bare repo processing or WalkDir + Mutex)

        // Assuming bare repo is NOT detected as exclusive container in this setup:
        let bare_repo_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("bare_repo.git"));
        assert!(
            bare_repo_entry.is_some(),
            "Bare repo itself should be listed if not exclusive container. Entries: {entries:?}"
        );
        assert_entry_properties(&entries, "bare_repo.git", "GitRepository", "bare_repo.git");

        let wt_a_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("wt_a"))
            .expect("wt_a not found");
        assert_eq!(wt_a_entry.display_name, "[bare_repo.git] wt_a"); // Updated expected display name
        match &wt_a_entry.entry_type {
            DirectoryType::GitWorktree {
                main_worktree_path, ..
            } => {
                // Removed worktree_name check
                // For a bare repo, main_worktree_path points to the bare repo itself.
                assert_eq!(
                    *main_worktree_path,
                    fs::canonicalize(&bare_repo_path).unwrap()
                );
            }
            _ => panic!(
                "wt_a Expected GitWorktree, found {:?}",
                wt_a_entry.entry_type
            ),
        }

        let wt_b_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("wt_b"))
            .expect("wt_b not found");
        assert_eq!(wt_b_entry.display_name, "[bare_repo.git] wt_b"); // Updated expected display name
        match &wt_b_entry.entry_type {
            DirectoryType::GitWorktree {
                main_worktree_path, ..
            } => {
                // Removed worktree_name check
                assert_eq!(
                    *main_worktree_path,
                    fs::canonicalize(&bare_repo_path).unwrap()
                );
            }
            _ => panic!(
                "wt_b Expected GitWorktree, found {:?}",
                wt_b_entry.entry_type
            ),
        }

        // Check that worktrees_of_bare (the containing directory) is also listed as Plain
        // UPDATE: Assuming check_if_worktree_container correctly skips "worktrees_of_bare"
        let worktrees_of_bare_entry = entries
            .iter()
            .find(|e| e.resolved_path.ends_with("worktrees_of_bare"));
        assert!(
            worktrees_of_bare_entry.is_none(),
            "worktrees_of_bare directory should be skipped. Entries: {entries:?}"
        );
        // assert_entry_properties(&entries, "worktrees_of_bare", "Plain", "worktrees_of_bare"); // Removed this line

        // Ensure no duplicates for worktrees
        let wt_a_count = entries
            .iter()
            .filter(|e| e.resolved_path.ends_with("wt_a"))
            .count();
        assert_eq!(wt_a_count, 1, "wt_a should appear exactly once");
        let wt_b_count = entries
            .iter()
            .filter(|e| e.resolved_path.ends_with("wt_b"))
            .count();
        assert_eq!(wt_b_count, 1, "wt_b should appear exactly once");

        // Total entries: bare_repo.git, wt_a, wt_b
        assert_eq!(
            entries.len(),
            3,
            "Expected 3 entries: bare repo and two worktrees. Entries: {:?}",
            &entries
        );
    }

    #[test]
    fn test_scan_deduplication_of_paths() {
        let temp_dir = tempdir().unwrap();
        let project_a_path = temp_dir.path().join("project_a");
        fs::create_dir(&project_a_path).unwrap();

        let mut config = default_test_config();
        // Add the same path multiple times via different routes
        config.search_paths = vec![temp_dir.path().to_path_buf()]; // Finds project_a
        config.additional_paths = vec![project_a_path.clone()]; // Explicitly adds project_a

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        // The Mutex<HashSet<PathBuf>> in `scan` should prevent the same resolved path
        // from being processed twice by `process_path_candidate`.
        assert_eq!(
            entries.len(),
            1,
            "Path added multiple ways should only appear once. Entries: {:?}",
            &entries
        );
        assert_entry_properties(&entries, "project_a", "Plain", "project_a");
    }

    #[test]
    fn test_search_path_is_git_repo_itself() {
        let temp_dir = tempdir().unwrap();
        let repo_path = temp_dir.path().join("my_repo");
        init_repo(&repo_path); // my_repo is a git repo
        fs::create_dir(repo_path.join("subdir")).unwrap(); // Add a subdir to it

        let mut config = default_test_config();
        // Add "my_repo" itself as a search path.
        // WalkDir starts *inside* the search path, so it will find "subdir".
        config.search_paths = vec![repo_path.clone()];

        let scanner = DirectoryScanner::new(&config);
        let entries = scanner.scan();

        // Expect "subdir" to be found as Plain. "my_repo" itself is the search root, not an entry found *within* it.
        assert_eq!(
            entries.len(),
            1,
            "Expected only subdir entry. Entries: {:?}",
            &entries
        );
        assert_entry_properties(&entries, "subdir", "Plain", "subdir");

        // If we want "my_repo" to be listed, it should be in additional_paths
        let mut config_additional = default_test_config();
        config_additional.additional_paths = vec![repo_path.clone()];
        let scanner_additional = DirectoryScanner::new(&config_additional);
        let entries_additional = scanner_additional.scan();
        assert_eq!(
            entries_additional.len(),
            1,
            "Expected my_repo entry from additional_paths. Entries: {:?}",
            &entries_additional
        );
        assert_entry_properties(&entries_additional, "my_repo", "GitRepository", "my_repo");
    }
}
